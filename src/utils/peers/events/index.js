const Peer = require('simple-peer');
const wrtc = require('wrtc');

const onConnect = (peers, peer) => {
  createMesh(peers, peer);
};

const createMesh = (peers, peer) => {
  /**
   * 1.- Peer connects to hub.
   * 2.- Hub creates a datachannel per node.
   * 3.- Hub creates 1 datachannel per existing node in the new peer.
   * 4.- The Hub pipes each connection to the new peer (so each peer has a direct connection with the newly created peer).
   * 5.- Each nodes starts signaling with the new peer until connected.
   * 6.- After connected, the new peer closes all the datachannels.
   * 7.- ???
   * 8.- Profit.
   */

  if(global._role === 'hub') {
    Object.entries(peers).forEach(([k, p]) => {
      if(k !== peer._id) {
        const ds = p._pc.createDataChannel(`mesh_signal_${peer._id}`);
        const dsl = peer._pc.createDataChannel(`mesh_signal_emitter_${k}`);

        ds.addEventListener('message', data => {
          dsl.send(data.data);
        });

        dsl.addEventListener('message', data => {
          ds.send(data.data);
        });
      }
    });
  }


  // eww, this needs refactor, all clients should be generated by the same function.
  const iceServers = [
    {
      urls: "stun:stun.l.google.com:19302"
    },
    {
      urls: "turn:company--1.com:3478?transport=udp",
      username: "test",
      credential: "test"
    },
    {
      urls: "turn:company--1.com:3478?transport=tcp",
      username: "test",
      credential: "test"
    }
  ];

  /**
   * This is moist af, should be dry.
   */
  if(global._role === 'worker') {
    peer._pc.addEventListener('datachannel', ({ channel }) => {
      const cname = channel.label;
      if(cname.indexOf('mesh_signal_') === 0) {
        const is_emitter = cname.indexOf('mesh_signal_emitter_') === 0;
        const newPeer = new Peer({ trickle: true, wrtc, iceServers, initiator: is_emitter });
        
        newPeer._id = cname.split('-').pop();
        
        newPeer.on('connect', () => {
          console.log(`mesh peer "${newPeer._id}" connected.`);
          peers[newPeer._id] = newPeer;
        });

        newPeer.on('signal', s => {
          channel.send(JSON.stringify(s));
        });

        channel.addEventListener('message', data => {
          newPeer.signal(JSON.parse(data.data));
        });
      }
    });
  }

};


module.exports = {
  onConnect
};